[comment encoding = UTF-8 /]
[**
 * Copyright (c) 2017 TU Ilmenau, Systems and Software Engineering Group
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */]
[module generateExecutionCMakeFile('http://www.eclipse.org/uml2/5.0.0/UML')]

[import fUML4CPP::generator::main::build_files::build_files_helper /]

[import fUML4CPP::generator::main::helpers::parameterHelper /]

[import UML4CPP::generator::main::helpers::nameHelper /]
[import UML4CPP::generator::main::helpers::isGeneratableHelper /]
[import UML4CPP::generator::main::helpers::generalHelper /]
[import UML4CPP::generator::main::profiles::strategyHelper /]


[template public generateExecutionCMakeFile(aPackage : Package, packageOnly : Boolean) { 
	packageName : String = getPackageName(); 
	execPackageName : String = getPackageName().concat('Exec');
}]
[comment ------------------------------------------------------------------- /]
[comment Generate CMakeLists.txt for model execution adapter                 /]
[comment ------------------------------------------------------------------- /]
[file (aPackage.generateNamespacePath(false).concat('Exec/').concat('CMakeLists.txt'), false, 'UTF-8')]
# DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN
# @generator: fuml4cpp::generator::main::generateExecutionBuildFile

# C++ project of model [packageName/].ecore, generated by fUML4CPP

CMAKE_MINIMUM_REQUIRED(VERSION 3.9)

[if (aPackage.isCrossCompileWindowsEnabled())]
# Cross-compilation support for Windows (MinGW)
# Set CMAKE_TOOLCHAIN_FILE if cross-compiling to Windows from Linux
IF(UNIX AND NOT APPLE)
    # Find toolchain file relative to MDE4CPP_HOME or project root
    string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})
    IF(MDE4CPP_HOME)
        SET(TOOLCHAIN_FILE "${MDE4CPP_HOME}/src/common/cmake/cmake-toolchain-mingw.cmake")
        IF(EXISTS ${TOOLCHAIN_FILE})
            set(CMAKE_TOOLCHAIN_FILE ${TOOLCHAIN_FILE} CACHE FILEPATH "Toolchain file" FORCE)
        ENDIF()
    ENDIF()
    # Also try relative to current source directory (for cases where MDE4CPP_HOME is not set)
    IF(NOT CMAKE_TOOLCHAIN_FILE)
        SET(TOOLCHAIN_FILE "${CMAKE_SOURCE_DIR}/../../../../src/common/cmake/cmake-toolchain-mingw.cmake")
        IF(EXISTS ${TOOLCHAIN_FILE})
            get_filename_component(TOOLCHAIN_FILE_ABS ${TOOLCHAIN_FILE} ABSOLUTE)
            set(CMAKE_TOOLCHAIN_FILE ${TOOLCHAIN_FILE_ABS} CACHE FILEPATH "Toolchain file" FORCE)
        ENDIF()
    ENDIF()
ENDIF()
[/if]

PROJECT([execPackageName/])

IF(NOT CMAKE_BUILD_TYPE) 
    SET(CMAKE_BUILD_TYPE Debug)
ENDIF(NOT CMAKE_BUILD_TYPE)
SET(CMAKE_DEBUG_POSTFIX d)

SET(CMAKE_CXX_STANDARD 17)

[comment IF("${CMAKE_CXX_COMPILER_ID}" STREQUAL "AppleClang") -> not necessary after removing openmp/]
SET(CMAKE_CXX_FLAGS "-Wall -Wno-overloaded-virtual -Wdeprecated-declarations -fmax-errors=5")
IF(APPLE)
  string(APPEND CMAKE_CXX_FLAGS " -Qunused-arguments")
ENDIF(APPLE)
SET(CMAKE_CXX_FLAGS_DEBUG " -Og -ggdb")
SET(CMAKE_CXX_FLAGS_RELEASE " -O3 -DNDEBUG")

string(REPLACE "\\" "/" MDE4CPP_HOME $ENV{MDE4CPP_HOME})

SET(SOURCE_FILES
	#Model Execution Plugin
	['impl/'.concat(aPackage.name).concat('ExecPluginImpl.cpp')/]
	[if (not packageOnly)]
	# Model Execution Locus
	impl/[aPackage.name/]LocusImpl.cpp
	# Model Executor
	impl/[aPackage.name/]ExecutorImpl.cpp
	# Model ExecutionFactory
	impl/[aPackage.name/]ExecutionFactoryImpl.cpp
	[/if]
	[aPackage.generatePackageSourceFilesToCompile(packageOnly, true)/]
)

INCLUDE_DIRECTORIES(
    ../
	${MDE4CPP_HOME}/application/include
)

# Apple specific stuff
IF(APPLE)
  SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -undefined dynamic_lookup")
  SET(CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS} -undefined dynamic_lookup")
ENDIF(APPLE)

# Check if cross-compiling to Windows (CMAKE_SYSTEM_NAME will be Windows, or MinGW compiler/toolchain is used)
# Note: When cross-compiling, CMAKE_SYSTEM_NAME is "Windows", so we check for cross-compilation first
SET(IS_CROSS_COMPILING FALSE)
IF(CMAKE_SYSTEM_NAME STREQUAL "Windows")
    SET(IS_CROSS_COMPILING TRUE)
ENDIF()
IF(NOT IS_CROSS_COMPILING)
    IF(DEFINED CMAKE_TOOLCHAIN_FILE AND CMAKE_TOOLCHAIN_FILE)
        string(FIND "${CMAKE_TOOLCHAIN_FILE}" "mingw" MINGW_POS)
        IF(MINGW_POS GREATER_EQUAL 0)
            SET(IS_CROSS_COMPILING TRUE)
        ENDIF()
    ENDIF()
ENDIF()
IF(NOT IS_CROSS_COMPILING)
    IF(DEFINED CMAKE_C_COMPILER AND CMAKE_C_COMPILER)
        string(FIND "${CMAKE_C_COMPILER}" "mingw" MINGW_POS)
        IF(MINGW_POS GREATER_EQUAL 0)
            SET(IS_CROSS_COMPILING TRUE)
        ENDIF()
    ENDIF()
ENDIF()

IF(IS_CROSS_COMPILING)
    # Cross-compiling to Windows from Linux - use .dll
	[generateCMakeFindLibraryCommands('.dll', 'bin')/]
ELSEIF(UNIX AND NOT APPLE)
    # Native Linux build - use .so
	[generateCMakeFindLibraryCommands('.so', 'bin')/]
ELSEIF(APPLE)
	[generateCMakeFindLibraryCommands('.dylib', 'bin')/]
ELSE()
	[generateCMakeFindLibraryCommands('', 'lib')/]
ENDIF()


ADD_LIBRARY(${PROJECT_NAME} SHARED ${SOURCE_FILES})
SET_TARGET_PROPERTIES(${PROJECT_NAME} PROPERTIES PREFIX "")

IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateLibraryLinking(true)/]
ELSE()
	[generateLibraryLinking(false)/]
ENDIF()

#-----------------------------------------------------
# DELIVERING binaries and header to ${MDE4CPP_HOME}
#-----------------------------------------------------

INSTALL(TARGETS ${PROJECT_NAME}
	RUNTIME DESTINATION ${MDE4CPP_HOME}/application/bin
	LIBRARY DESTINATION ${MDE4CPP_HOME}/application/bin
    ARCHIVE DESTINATION ${MDE4CPP_HOME}/application/lib
)

INSTALL(DIRECTORY . DESTINATION ${MDE4CPP_HOME}/application/include/${PROJECT_NAME}
	FILES_MATCHING PATTERN "*.hpp"
	PATTERN ".cmake" EXCLUDE
)
[/file]
[/template]

[template private generatePackageSourceFilesToCompile(aPackage : Package, packOnly : Boolean, isRoot : Boolean)]
#Strategy classes for Package [aPackage.generateNamespace(false)/]
[for (aClass : Class | getPackageClasses()->select(isStrategyClass())->sortedBy(name))]
[if(not isRoot)]../[aPackage.generateNamespacePath(false)/]Exec/[/if][aClass.name.toUpperFirst()/].cpp
[/for]
[for (subPackage : Package | aPackage.ownedElement->filter(Package))]
[subPackage.generatePackageSourceFilesToCompile(packOnly, false)/]
[/for]
[/template]

[template private generateCMakeFindLibraryCommands(aPackage : Package, ending : String, folderName : String)]
IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, true)/]
ELSE()
	[generateCMakeFindLibraryCommand(aPackage, ending, folderName, false)/]
ENDIF()
[/template]

[template private generateCMakeFindLibraryCommand(aPackage : Package, ending : String, folderName : String, debugMode : Boolean)]
[if (ending = '.dll')]
[comment When cross-compiling to Windows, use SET with CACHE FORCE since FIND_LIBRARY doesn't work well with .dll files /]
[comment Unset any previous NOTFOUND values first /]
[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name)))]
UNSET([packName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] CACHE)
SET([packName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] "${MDE4CPP_HOME}/application/[folderName/]/[packName/][libraryNameSuffix(debugMode)/][ending/]" CACHE FILEPATH "[packName/] [libraryVariableNameSuffix(debugMode)/] library" FORCE)
[if (OrderedSet{'ecore', 'uml', 'fUML', 'PSCS', 'PSSM', 'ecoreReflection', 'umlReflection','primitivetypesReflection', 'oclParser', aPackage.getPackageName()}->excludes(packName))]
UNSET([packName.toUpperCase()/]EXEC_[libraryVariableNameSuffix(debugMode)/] CACHE)
SET([packName.toUpperCase()/]EXEC_[libraryVariableNameSuffix(debugMode)/] "${MDE4CPP_HOME}/application/[folderName/]/[packName/]Exec[libraryNameSuffix(debugMode)/][ending/]" CACHE FILEPATH "[packName/]Exec [libraryVariableNameSuffix(debugMode)/] library" FORCE)
[/if]
[/for]
UNSET(PLUGINFRAMEWORK_[libraryVariableNameSuffix(debugMode)/] CACHE)
SET(PLUGINFRAMEWORK_[libraryVariableNameSuffix(debugMode)/] "${MDE4CPP_HOME}/application/[folderName/]/pluginFramework[libraryNameSuffix(debugMode)/][ending/]" CACHE FILEPATH "pluginFramework [libraryVariableNameSuffix(debugMode)/] library" FORCE)
[else]
[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name)))]
FIND_LIBRARY([packName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/] [packName/][libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[if (OrderedSet{'ecore', 'uml', 'fUML', 'PSCS', 'PSSM', 'ecoreReflection', 'umlReflection','primitivetypesReflection', 'oclParser', aPackage.getPackageName()}->excludes(packName))]
FIND_LIBRARY([packName.toUpperCase()/]EXEC_[libraryVariableNameSuffix(debugMode)/] [packName/]Exec[libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/if]
[/for]
FIND_LIBRARY(PLUGINFRAMEWORK_[libraryVariableNameSuffix(debugMode)/] pluginFramework[libraryNameSuffix(debugMode)/][ending/] ${MDE4CPP_HOME}/application/[folderName/])
[/if]
[/template]

[template private generateLibraryLinking(aPackage : Package, debugMode : Boolean)]
TARGET_LINK_LIBRARIES(${PROJECT_NAME}
[for (packName : String | aPackage.metaModelLibrariesNames()->reject(name : String | aPackage.getAllSubPackageNames()->includes(name)))]
	[buildModeCMakeProperty(debugMode)/] ${[packName.toUpperCase()/]_[libraryVariableNameSuffix(debugMode)/]}
	[if (OrderedSet{'ecore', 'uml', 'fUML', 'PSCS', 'PSSM', 'ecoreReflection', 'umlReflection','primitivetypesReflection', 'oclParser', aPackage.getPackageName()}->excludes(packName))]
	[buildModeCMakeProperty(debugMode)/] ${[packName.toUpperCase()/]EXEC_[libraryVariableNameSuffix(debugMode)/]}
	[/if]
[/for]
	[buildModeCMakeProperty(debugMode)/] ${PLUGINFRAMEWORK_[libraryVariableNameSuffix(debugMode)/]}
	${CMAKE_DL_LIBS}
)
[/template]

[query private libraryVariableNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'DEBUG' else 'RELEASE' endif/]
[query private libraryNameSuffix(debugMode : Boolean) : String = if (debugMode) then 'd' else '' endif/]
[query private buildModeCMakeProperty(debugMode : Boolean) : String = if (debugMode) then 'debug' else 'optimized' endif/]